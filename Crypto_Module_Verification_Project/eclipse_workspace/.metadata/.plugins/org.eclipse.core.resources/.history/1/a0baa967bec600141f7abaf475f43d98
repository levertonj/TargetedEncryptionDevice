/*
 * "Hello World" example.
 *
 * This example prints 'Hello from Nios II' to the STDOUT stream. It runs on
 * the Nios II 'standard', 'full_featured', 'fast', and 'low_cost' example
 * designs. It runs with or without the MicroC/OS-II RTOS and requires a STDOUT
 * device in your system's hardware.
 * The memory footprint of this hosted application is ~69 kbytes by default
 * using the standard reference design.
 *
 * For a reduced footprint version of this template, and an explanation of how
 * to reduce the memory footprint for a given application, see the
 * "small_hello_world" template.
 *
 */

#include <stdio.h>
#include "system.h"

#define VAL_1X			1
#define VAL_2X			VAL_1X, VAL_1X
#define VAL_4X			VAL_2X, VAL_2X
#define VAL_8X			VAL_4X, VAL_4X
#define VAL_16X			VAL_8X, VAL_8X
#define VAL_32X			VAL_16X, VAL_16X
#define VAL_64X			VAL_32X, VAL_32X
#define VAL_128X		VAL_64X, VAL_64X
#define VAL_256X		VAL_128X, VAL_128X
#define VAL_512X		VAL_256X, VAL_256X
#define VAL_1024X		VAL_512X, VAL_512X
#define VAL_2048X		VAL_1024X, VAL_1024X

#define ENCRYPT 1
#define DECRYPT 3

struct crypto_t{
	unsigned int control;
	unsigned int status;
	unsigned int readStart;
	unsigned int writeStart;
	unsigned int transferLength;
	unsigned int injectionVector;
	unsigned int key8key16;
	unsigned int key32;
};



unsigned int plaintext_A[512] 		__attribute__ ((section (".incoming_memory")));
unsigned int encrypted_A[512] 		__attribute__ ((section (".outgoing_memory")));
unsigned int decrypted_A[512] 		__attribute__ ((section (".incoming_memory")));

unsigned int plaintext_B[512]  		__attribute__ ((section (".incoming_memory")));
unsigned int encrypted_B[512]  	  	__attribute__ ((section (".outgoing_memory")));
unsigned int decrypted_B[512]  		__attribute__ ((section (".incoming_memory")));

struct crypto_t * Crypto = (struct crypto_t *) CRYPTO_MODULE_BASE;

int main()
{

  int i;
  int x = 1500;
  unsigned int startTime, endTime;

  char largest_payload[] = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla nec mi non arcu commodo porttitor. Nullam maximus mollis tortor. \
Sed lacinia eros tortor, porta consectetur sem facilisis in. Nulla nibh mauris, sagittis et nibh in, sollicitudin sodales nisl. Vestibulum sed egestas \
odio, nec tempus erat. Cras non tortor sagittis, consectetur arcu a, tincidunt magna. Integer vel gravida odio. Fusce posuere nibh a lacus tincidunt \
maximus. Pellentesque porttitor dolor nec rutrum efficitur. Etiam commodo erat ligula, imperdiet rutrum massa interdum vitae. Fusce vulputate mattis \
tincidunt. Proin lobortis est volutpat hendrerit tincidunt. Etiam mattis nisl sed orci sodales, vitae fringilla quam molestie. Pellentesque venenatis \
sapien augue, id lacinia felis mollis luctus. Maecenas nec lacinia odio. Phasellus lorem erat, iaculis eu dictum ac, rutrum vitae sapien. Curabitur \
dignissim ut enim eget malesuada. Etiam tincidunt erat ante, eget ullamcorper sapien hendrerit quis. Cras finibus elit at orci accumsan semper. Etiam \
convallis mollis nisi vel semper. Proin laoreet vulputate est, sed pellentesque enim volutpat et. Vestibulum tempor ipsum nec efficitur faucibus. Quisque \
ut fringilla orci, consectetur convallis urna. Nullam vestibulum sodales odio porttitor mollis. Proin viverra arcu mauris, vel congue ante semper non. \
Donec nec maris bibendum, suscipit mi vel, congue nisl. Suspendisse sit amet porta ipsum, vel dignissim magna. In aliquam arcu at mi dictum consectetur. \
Donec massa nunc.";

  memcpy(plaintext_A, largest_payload, x);
  memcpy(plaintext_B, largest_payload, x);

  alt_timestamp_start();

  printf("Address (plain) = 0x%x\n", &plaintext_A[0]);
  printf("Address (encrypted) = 0x%x\n", &encrypted_A[0]);
  printf("Address (decrypted) = 0x%x\n", &decrypted_A[0]);

  Crypto->readStart = &plaintext_A[0];
  printf("readStart = ? 0x%08x\n", Crypto->readStart);
  Crypto->writeStart = &encrypted_A[0];
  printf("writeStart = ? 0x%08x\n", Crypto->writeStart);
  Crypto->transferLength = x;
  printf("transferLength = 1500? %d\n", Crypto->transferLength);
  Crypto->injectionVector = 0xdeadbeef;
  printf("injectionVector = 0x%08x\n", Crypto->injectionVector);
  Crypto->key8key16 = 0x00a6beef;
  printf("key8key16 = 0x%08x\n", Crypto->key8key16);
  Crypto->key32 = 0x1245678;
  printf("key32 = 0x%08x\n", Crypto->key32);

  startTime = alt_timestamp();
  Crypto->control = ENCRYPT;

  while((Crypto->status & 0x1) == 1){
  }
  endTime = alt_timestamp();
  printf("\nEncryption done!\n");
  printf("Hardware encryption time was %.12f s!\n\n", ((double)(endTime-startTime)/(double)alt_timestamp_freq()));

  Crypto->readStart = &encrypted_A[0];
  Crypto->writeStart = &decrypted_A[0];

  startTime = alt_timestamp();
  Crypto->control = DECRYPT;

  while((Crypto->status & 0x1) == 1){
  }
  endTime = alt_timestamp();
  printf("Decryption done!\n");
  printf("Hardware decryption time was %.12f s!\n\n", ((double)(endTime-startTime)/(double)alt_timestamp_freq()));
  printf("Done Hardware crypto!\n\n");

  printf("Plaintext: ");
  for (i = 0; i < x; i++){
	printf("%c", *(((char*)&plaintext_A[0])+i));
  }
  printf("\n\n");

  printf("Encrypted: ");
  for (i = 0; i < x; i++){
	printf("%c", *(((char*)&encrypted_A[0])+i));
  }
  printf("\n\n");

  printf("Decrypted: ");
  for (i = 0; i < x; i++){
	printf("%c", *(((char*)&decrypted_A[0])+i));
  }
  printf("\n\n");

  printf("Beginning encryption by processor");
  printf("Plaintext address: %.8x\n", &plaintext_B[0]);
  printf("Encrypted address: %.8x\n", &encrypted_B[0]);
  printf("Decrypted address: %.8x\n", &decrypted_B[0]);
  CryptoProcedure(0, &plaintext_B[0], &encrypted_B[0], x, 0xdeadbeef, 0xa6, 0xbeef, 0x1245678);
  printf("Encryption done!\n");
  CryptoProcedure(1, &encrypted_B[0], &decrypted_B[0], x, 0xdeadbeef, 0xa6, 0xbeef, 0x1245678);
  printf("Decryption done!\n");


  return 0;
}

void CryptoProcedure(unsigned char control, unsigned int readstart, unsigned int writestart, unsigned int transferlength, unsigned int injectionvector, unsigned char key8, unsigned short key16, unsigned int key32){
	unsigned int key8_32 = (key8<<24) | (key8<<16) | (key8<<8) | (key8);
	unsigned int key16_32 = (key16<<16) | (key16);
	unsigned int key32_32 = key32;
	unsigned int injectionvector_32 = injectionvector;
	unsigned int writeaddress = writestart & 0xfffffffc;
	unsigned int readaddress = readstart & 0xfffffffc;
	unsigned int rotationcounter = 0;

	unsigned int byteswritten = 0;

	if (control == 0){
		switch (readstart & 0x3){
			case(0x0):
				readaddress &= 0xfffffffc;
				if (transferlength == 3){
					injectionvector = (*readaddress & 0x000000ff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xffffff00);
					*writeaddress = injectionvector;
					byteswritten += 3;
				} else if (transferlength == 2){
					injectionvector = (*readaddress & 0x0000ffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xffff0000);
					*writeaddress = injectionvector;
					byteswritten += 2;
				} else if (transferlength == 1){
					injectionvector = (*readaddress & 0x00ffffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xff000000);
					*writeaddress = injectionvector;
					byteswritten += 1;
				} else {
					injectionvector = (*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32);
					*writeaddress = injectionvector;
					byteswritten += 4;
				}
				break;
			case(0x1):
				readaddress &= 0xfffffffc;
				if (transferlength == 2){
					injectionvector = (*readaddress & 0x0000ffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xffff0000);
					*writeaddress = injectionvector;
					byteswritten += 2;
				} else if (transferlength == 1){
					injectionvector = (*readaddress & 0x00ffffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xff000000);
					*writeaddress = injectionvector;
					byteswritten += 1;
				} else {
					injectionvector = (*readaddress & 0x000000ff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xffffff00);
					*writeaddress = injectionvector;
					byteswritten += 3;;
				}
				break;
			case(0x2):
				readaddress &= 0xfffffffc;
				if (transferlength == 1){
					injectionvector = (*readaddress & 0x00ffffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xff000000);
					*writeaddress = injectionvector;
					byteswritten += 1;
				} else {
					injectionvector = (*readaddress & 0x0000ffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xffff0000);
					*writeaddress = injectionvector;
					byteswritten += 2;
				}
				break;
			case(0x3):
				readaddress &= 0xfffffffc;
				injectionvector = (*readaddress & 0x00ffffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xff000000);
				*writeaddress = injectionvector;
				byteswritten += 1;
				break;
		}

		readaddress += 0x4;
		writeaddress += 0x4;

		while(byteswritten < transferlength){
			rotationcounter += 1;
			key32_32 = (key32_32 >> 1) | (key32_32 << 31);
			if ((rotationcounter & 0x1f) == 0x1){
				key16_32 = (key16_32 >> 1) | (key16_32 << 31);
			}
			if ((rotationcounter & 0x7f) == 0x1){
				key8_32 = (key8_32 >> 1) | (key8_32 << 31);
			}
			switch (transferlength - byteswritten){
				case (3):
					injectionvector = (*readaddress & 0xff000000) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0x00ffffff);
					*writeaddress = injectionvector;
					byteswritten += 3;
					break;
				case (2):
					injectionvector = (*readaddress & 0xffff0000) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0x0000ffff);
					*writeaddress = injectionvector;
					byteswritten += 2;
					break;
				case (1):
					injectionvector = (*readaddress & 0xffffff00) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0x000000ff);
					*writeaddress = injectionvector;
					byteswritten += 1;
					break;
				default:
					injectionvector = (*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32);
					*writeaddress = injectionvector;
					byteswritten += 4;
					break;
			}
			readaddress += 0x4;
			writeaddress += 0x4;
		}
	} else if (control == 1){
		switch (readstart & 0x3){
			case(0x0):
				readaddress &= 0xfffffffc;
				if (transferlength == 3){
					*writeaddress = (*readaddress & 0x000000ff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xffffff00);
					injectionvector = *readaddress;
					byteswritten += 3;
				} else if (transferlength == 2){
					*writeaddress = (*readaddress & 0x0000ffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xffff0000);
					injectionvector = *readaddress;
					byteswritten += 2;
				} else if (transferlength == 1){
					*writeaddress = (*readaddress & 0x00ffffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xff000000);
					injectionvector = *readaddress;
					byteswritten += 1;
				} else {
					*writeaddress = (*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32);
					injectionvector = *readaddress;
					byteswritten += 4;
				}
				break;
			case(0x1):
				readaddress &= 0xfffffffc;
				if (transferlength == 2){
					*writeaddress = (*readaddress & 0x0000ffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xffff0000);
					injectionvector = *readaddress;
					byteswritten += 2;
				} else if (transferlength == 1){
					*writeaddress = (*readaddress & 0x00ffffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xff000000);
					injectionvector = *readaddress;
					byteswritten += 1;
				} else {
					*writeaddress = (*readaddress & 0x000000ff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xffffff00);
					injectionvector = *readaddress;
					byteswritten += 3;;
				}
				break;
			case(0x2):
				readaddress &= 0xfffffffc;
				if (transferlength == 1){
					*writeaddress = (*readaddress & 0x00ffffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xff000000);
					injectionvector = *readaddress;
					byteswritten += 1;
				} else {
					*writeaddress = (*readaddress & 0x0000ffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xffff0000);
					injectionvector = *readaddress;
					byteswritten += 2;
				}
				break;
			case(0x3):
				readaddress &= 0xfffffffc;
				*writeaddress = (*readaddress & 0x00ffffff) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0xff000000);
				injectionvector = *readaddress;
				byteswritten += 1;
				break;
		}

		readaddress += 0x4;
		writeaddress += 0x4;

		while(byteswritten < transferlength){
			rotationcounter += 1;
			key32_32 = (key32_32 >> 1) | (key32_32 << 31);
			if ((rotationcounter & 0x1f) == 0x1){
				key16_32 = (key16_32 >> 1) | (key16_32 << 31);
			}
			if ((rotationcounter & 0x7f) == 0x1){
				key8_32 = (key8_32 >> 1) | (key8_32 << 31);
			}
			switch (transferlength - byteswritten){
				case (3):
					*writeaddress = (*readaddress & 0xff000000) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0x00ffffff);
					injectionvector = *readaddress;
					byteswritten += 3;
					break;
				case (2):
					*writeaddress = (*readaddress & 0xffff0000) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0x0000ffff);
					injectionvector = *readaddress;
					byteswritten += 2;
					break;
				case (1):
					*writeaddress = (*readaddress & 0xffffff00) | ((*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32) & 0x000000ff);
					injectionvector = *readaddress;
					byteswritten += 1;
					break;
				default:
					*writeaddress = (*readaddress ^ injectionvector ^ key8_32 ^ key16_32 ^ key32_32);
					injectionvector = *readaddress;
					byteswritten += 4;
					break;
			}
			readaddress += 0x4;
			writeaddress += 0x4;
		}
	}
}
